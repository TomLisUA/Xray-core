// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go
//
// Generated by this command:
//
//	mockgen -destination=mocks/client_mocks.go -source=interfaces.go -package=mocks -typed
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	io "io"
	reflect "reflect"

	route "github.com/goxray/core/network/route"
	gomock "go.uber.org/mock/gomock"
)

// Mockpipe is a mock of pipe interface.
type Mockpipe struct {
	ctrl     *gomock.Controller
	recorder *MockpipeMockRecorder
	isgomock struct{}
}

// MockpipeMockRecorder is the mock recorder for Mockpipe.
type MockpipeMockRecorder struct {
	mock *Mockpipe
}

// NewMockpipe creates a new mock instance.
func NewMockpipe(ctrl *gomock.Controller) *Mockpipe {
	mock := &Mockpipe{ctrl: ctrl}
	mock.recorder = &MockpipeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockpipe) EXPECT() *MockpipeMockRecorder {
	return m.recorder
}

// Copy mocks base method.
func (m *Mockpipe) Copy(ctx context.Context, pipe io.ReadWriteCloser, socks5 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Copy", ctx, pipe, socks5)
	ret0, _ := ret[0].(error)
	return ret0
}

// Copy indicates an expected call of Copy.
func (mr *MockpipeMockRecorder) Copy(ctx, pipe, socks5 any) *MockpipeCopyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Copy", reflect.TypeOf((*Mockpipe)(nil).Copy), ctx, pipe, socks5)
	return &MockpipeCopyCall{Call: call}
}

// MockpipeCopyCall wrap *gomock.Call
type MockpipeCopyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockpipeCopyCall) Return(arg0 error) *MockpipeCopyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockpipeCopyCall) Do(f func(context.Context, io.ReadWriteCloser, string) error) *MockpipeCopyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockpipeCopyCall) DoAndReturn(f func(context.Context, io.ReadWriteCloser, string) error) *MockpipeCopyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockipTable is a mock of ipTable interface.
type MockipTable struct {
	ctrl     *gomock.Controller
	recorder *MockipTableMockRecorder
	isgomock struct{}
}

// MockipTableMockRecorder is the mock recorder for MockipTable.
type MockipTableMockRecorder struct {
	mock *MockipTable
}

// NewMockipTable creates a new mock instance.
func NewMockipTable(ctrl *gomock.Controller) *MockipTable {
	mock := &MockipTable{ctrl: ctrl}
	mock.recorder = &MockipTableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockipTable) EXPECT() *MockipTableMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockipTable) Add(options route.Opts) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", options)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockipTableMockRecorder) Add(options any) *MockipTableAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockipTable)(nil).Add), options)
	return &MockipTableAddCall{Call: call}
}

// MockipTableAddCall wrap *gomock.Call
type MockipTableAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockipTableAddCall) Return(arg0 error) *MockipTableAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockipTableAddCall) Do(f func(route.Opts) error) *MockipTableAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockipTableAddCall) DoAndReturn(f func(route.Opts) error) *MockipTableAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockipTable) Delete(options route.Opts) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", options)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockipTableMockRecorder) Delete(options any) *MockipTableDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockipTable)(nil).Delete), options)
	return &MockipTableDeleteCall{Call: call}
}

// MockipTableDeleteCall wrap *gomock.Call
type MockipTableDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockipTableDeleteCall) Return(arg0 error) *MockipTableDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockipTableDeleteCall) Do(f func(route.Opts) error) *MockipTableDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockipTableDeleteCall) DoAndReturn(f func(route.Opts) error) *MockipTableDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockrunnable is a mock of runnable interface.
type Mockrunnable struct {
	ctrl     *gomock.Controller
	recorder *MockrunnableMockRecorder
	isgomock struct{}
}

// MockrunnableMockRecorder is the mock recorder for Mockrunnable.
type MockrunnableMockRecorder struct {
	mock *Mockrunnable
}

// NewMockrunnable creates a new mock instance.
func NewMockrunnable(ctrl *gomock.Controller) *Mockrunnable {
	mock := &Mockrunnable{ctrl: ctrl}
	mock.recorder = &MockrunnableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockrunnable) EXPECT() *MockrunnableMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *Mockrunnable) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockrunnableMockRecorder) Close() *MockrunnableCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*Mockrunnable)(nil).Close))
	return &MockrunnableCloseCall{Call: call}
}

// MockrunnableCloseCall wrap *gomock.Call
type MockrunnableCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrunnableCloseCall) Return(arg0 error) *MockrunnableCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrunnableCloseCall) Do(f func() error) *MockrunnableCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrunnableCloseCall) DoAndReturn(f func() error) *MockrunnableCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *Mockrunnable) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockrunnableMockRecorder) Start() *MockrunnableStartCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*Mockrunnable)(nil).Start))
	return &MockrunnableStartCall{Call: call}
}

// MockrunnableStartCall wrap *gomock.Call
type MockrunnableStartCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockrunnableStartCall) Return(arg0 error) *MockrunnableStartCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockrunnableStartCall) Do(f func() error) *MockrunnableStartCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockrunnableStartCall) DoAndReturn(f func() error) *MockrunnableStartCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockioReadWriteCloser is a mock of ioReadWriteCloser interface.
type MockioReadWriteCloser struct {
	ctrl     *gomock.Controller
	recorder *MockioReadWriteCloserMockRecorder
	isgomock struct{}
}

// MockioReadWriteCloserMockRecorder is the mock recorder for MockioReadWriteCloser.
type MockioReadWriteCloserMockRecorder struct {
	mock *MockioReadWriteCloser
}

// NewMockioReadWriteCloser creates a new mock instance.
func NewMockioReadWriteCloser(ctrl *gomock.Controller) *MockioReadWriteCloser {
	mock := &MockioReadWriteCloser{ctrl: ctrl}
	mock.recorder = &MockioReadWriteCloserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockioReadWriteCloser) EXPECT() *MockioReadWriteCloserMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockioReadWriteCloser) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockioReadWriteCloserMockRecorder) Close() *MockioReadWriteCloserCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockioReadWriteCloser)(nil).Close))
	return &MockioReadWriteCloserCloseCall{Call: call}
}

// MockioReadWriteCloserCloseCall wrap *gomock.Call
type MockioReadWriteCloserCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockioReadWriteCloserCloseCall) Return(arg0 error) *MockioReadWriteCloserCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockioReadWriteCloserCloseCall) Do(f func() error) *MockioReadWriteCloserCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockioReadWriteCloserCloseCall) DoAndReturn(f func() error) *MockioReadWriteCloserCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Read mocks base method.
func (m *MockioReadWriteCloser) Read(p []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockioReadWriteCloserMockRecorder) Read(p any) *MockioReadWriteCloserReadCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockioReadWriteCloser)(nil).Read), p)
	return &MockioReadWriteCloserReadCall{Call: call}
}

// MockioReadWriteCloserReadCall wrap *gomock.Call
type MockioReadWriteCloserReadCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockioReadWriteCloserReadCall) Return(n int, err error) *MockioReadWriteCloserReadCall {
	c.Call = c.Call.Return(n, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockioReadWriteCloserReadCall) Do(f func([]byte) (int, error)) *MockioReadWriteCloserReadCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockioReadWriteCloserReadCall) DoAndReturn(f func([]byte) (int, error)) *MockioReadWriteCloserReadCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Write mocks base method.
func (m *MockioReadWriteCloser) Write(p []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", p)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Write indicates an expected call of Write.
func (mr *MockioReadWriteCloserMockRecorder) Write(p any) *MockioReadWriteCloserWriteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockioReadWriteCloser)(nil).Write), p)
	return &MockioReadWriteCloserWriteCall{Call: call}
}

// MockioReadWriteCloserWriteCall wrap *gomock.Call
type MockioReadWriteCloserWriteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockioReadWriteCloserWriteCall) Return(n int, err error) *MockioReadWriteCloserWriteCall {
	c.Call = c.Call.Return(n, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockioReadWriteCloserWriteCall) Do(f func([]byte) (int, error)) *MockioReadWriteCloserWriteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockioReadWriteCloserWriteCall) DoAndReturn(f func([]byte) (int, error)) *MockioReadWriteCloserWriteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
